---
import "@/styles/globals.css";
import { db, Document, eq } from "astro:db";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { DocumentMenu } from "@/components/ui/document-menu";

import Layout from "@/components/custom/layout.astro";
import Particles from "@/components/custom/particles.astro";
import DocumentHeader from "@/components/custom/document-header.astro";
import ContentEditable from "@/components/custom/content-editable.astro";
import { defaultLocale, getClientTranslations, getPreferredLocale, getTranslations } from "@/utils/i18n.ts";

const { doc } = Astro.params;
if (!doc) return;

const entry = await db.select().from(Document).where(eq(Document.id, doc)).get();
if (!entry) return;

const locale = getPreferredLocale(Astro.request.headers) ?? defaultLocale;
const i18n = getTranslations(locale);

// TODO: Move DocumentMenu to a reusable component and remove here
const client = getClientTranslations(locale);
---

<Layout title={entry.name} description="Doc" locale={locale}>
    <Particles data={{ id: entry.id, version: entry.version }}></Particles>
    <div class="h-full flex gap-4">
        <div class="flex-1" transition:name={entry.id}>
            <Card className="h-full flex-1 overflow-auto">
                <CardHeader>
                    <DocumentHeader doc={entry}>
                        <ContentEditable slot="title" placeholder={i18n("new-document")}>
                            {entry.name}
                        </ContentEditable>
                        <DocumentMenu
                            slot="actions"
                            id={entry.id}
                            document={entry.document}
                            version={entry.version}
                            translations={client}
                            client:only="react"
                        ></DocumentMenu>
                    </DocumentHeader>
                </CardHeader>
                <CardContent>
                    <article id="input" class="whitespace-pre-line" data-placeholder={i18n("write-something")}>
                        {entry.markdown}
                    </article>
                </CardContent>
            </Card>
        </div>
        <Card className="h-full flex-1 overflow-auto">
            <CardHeader>
                <CardTitle>
                    {i18n("preview")}
                </CardTitle>
            </CardHeader>
            <CardContent className="prose dark:prose-invert mx-auto">
                <article id="output"></article>
            </CardContent>
        </Card>
    </div>
</Layout>

<script>
    import { actions } from "astro:actions";
    import { standardKeymap, historyKeymap, history } from "@codemirror/commands";
    import { EditorView, keymap, placeholder } from "@codemirror/view";
    import { markdown } from "@codemirror/lang-markdown";
    import { getParticles } from "@/utils/particles.ts";
    import { debounce } from "@/utils/debounce.ts";
    import { ContentEditable } from "@/components/custom/content-editable.ts";
    import markdownit from "markdown-it";

    const md = markdownit({
        html: true,
        breaks: true
    });

    document.addEventListener("astro:page-load", () => {
        const { id, version } = getParticles<{ id: string; version?: number; }>();

        const input = document.getElementById("input");
        const output = document.getElementById("output");
        if (!input || !output) return;

        const fallback = input.getAttribute("data-placeholder") ?? String();
        const content = input.textContent?.trim() ?? String();
        input.textContent = String();

        const setMarkdown = debounce((value: string) => {
            actions.updateDocument({
                id,
                markdown: value
            });
        }, 1000);

        const values: Record<string, string | undefined> = {};
        new EditorView({
            parent: input,
            doc: content,
            extensions: [
                EditorView.lineWrapping,
                keymap.of(standardKeymap),
                keymap.of(historyKeymap),
                history(),
                markdown(),
                placeholder(fallback),
                EditorView.editable.of(!version),
                EditorView.updateListener.of(update => {
                    if (update.docChanged || update.heightChanged) {
                        const value = update.state.doc.toString();
                        if (update.docChanged) setMarkdown(value);

                        // TODO: Evaluate whether to create markdown-it plugin
                        const replaced = value.replace(/\[(\S+)\]/g, (_, key) => {
                            const value = values[key] ?? String();
                            return `<content-editable value="${value}" placeholder="${key}"></content-editable>`;
                        });

                        // TODO: Evaluate whether to create markdown-it plugin
                        const html = md.render(replaced);
                        const parsed = new DOMParser().parseFromString(html, "text/html");
                        for (const element of parsed.querySelectorAll("h1, h2, h3, p")) {
                            const [match, tailwind] = element.textContent?.match(/^([a-z0-9-]+):/) ?? [];
                            if (!match) continue;

                            element.innerHTML = element.innerHTML.replace(match, String());
                            element.classList.add(tailwind);
                        }

                        output.innerHTML = new XMLSerializer().serializeToString(parsed);
                    }
                })
            ]
        });

        const nameInput = document.querySelector("div[contenteditable]");
        nameInput?.addEventListener("blur", () => {
            if (nameInput) {
                actions.updateDocument({
                    id,
                    name: nameInput.textContent ?? String()
                });
            }
        });

        output.addEventListener("input", ({ target }) => {
            if (target instanceof ContentEditable) {
                const { value, placeholder } = target;
                values[placeholder] = value;

                // Update inputs sharing the same placeholder (i.e., variable name)
                for (const element of output.querySelectorAll(`[placeholder="${placeholder}"]`)) {
                    if (element !== target) element.setAttribute("value", value);
                }
            }
        });
    });
</script>

<style is:inline>
    .cm-editor.cm-focused {
        outline: none;
    }

    .cm-editor .cm-scroller, .cm-editor .cm-content, .cm-editor .cm-line {
        padding: unset;
        font-family: inherit;
        font-size: inherit;
        font-weight: inherit;
        line-height: inherit;
        caret-color: inherit;
    }

    .cm-editor .cm-placeholder {
        color: hsl(var(--placeholder));
    }

    .prose h1, .prose h2, .prose h3, .prose p {
        margin-top: 0;
    }
</style>
